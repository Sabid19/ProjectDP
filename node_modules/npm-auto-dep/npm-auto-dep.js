#!/usr/local/bin/node
var when = require('when');
when.guard = require('when/guard');
when.nodefn = require('when/node/function')
var fs = require('fs');
var readline = require('readline');
var ChildProcess = require('child_process');
var readline = require('readline');
var semver = require('semver');
var optimist = require('optimist');
var colors = require('colors');
var util = require('util');

var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

var bundled_modules = [
	'assert',
	'buffer',
	'child_process',
	'cluster',
	'console',
	'constants',
	'crypto',
	'dgram',
	'dns',
	'domain',
	'events',
	'freelist',
	'fs',
	'http',
	'https',
	'module',
	'net',
	'os',
	'path',
	'punycode',
	'querystring',
	'readline',
	'repl',
	'stream',
	'string_decoder',
	'sys',
	'timers',
	'tls',
	'tty',
	'url',
	'util',
	'vm',
	'zlib'
];
function realpathPromise(dir){
	var deferred = when.defer();
	fs.realpath(dir, when.nodefn.createCallback(deferred.resolver));
	return deferred.promise;
}
function getModulePaths(module_directory){
	var paths = [];
	paths.push(process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME']+'/.node_modules');
	paths.push(process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME']+'/.node_libraries');
	paths.push(process.config.variables.node_prefix+'/lib/node/'); //I don't think that works...
	if(process.env['NODE_PATH']){
		paths.concat(process.env['NODE_PATH'].split((process.platform == 'win32') ? ';' : ':'));
	}
	var i=0;
	
	function upTheTree(paths, dir)
	{
		paths.push(dir+'/node_modules');
		if(++i > 256){
			return when.reject(new Error('resolving paths is hard, and I failed', paths));
		}
		if(dir != '/'){
			dir = dir+'/..';
			return realpathPromise(dir).then(upTheTree.bind(null, paths));
		} else {
			return when.resolve(paths);
		}
	}
	return realpathPromise(module_directory).then(upTheTree.bind(null, paths));
	
}
function getDependenciesMetadata(paths, require_argument){
	var metadata_promise = when.reject(true);
	
	paths.forEach(function(entry){
		metadata_promise = metadata_promise.otherwise(function(){
			var deferred = when.defer();
			fs.readFile(entry+'/'+require_argument+'/package.json', when.nodefn.createCallback(deferred.resolver));
			return deferred.promise;
		});
	});
	return metadata_promise.then(function(file_contents){
		return when.resolve(JSON.parse(file_contents.toString(0)));
	})
}
function getModuleMetadata(directory){
	var deferred = when.defer();
	fs.readFile(directory+'/package.json', when.nodefn.createCallback(deferred.resolver));
	return deferred.promise.then(JSON.parse);

}
function askVersion(rl, name, current_version){
	function ask(){
		var deferred = when.defer();
		rl.multilineQuestion('Enter version specification (see man 7 semver)\n> ', function(answer){
			answer = answer.trim();
			if(!answer.length){
				return deferred.resolver.resolve(null);
			}
			if(semver.validRange(answer)){
				return deferred.resolver.resolve([name, answer])
			} else {
				rl.write('Invalid input. Try again.\n'.red);
				deferred.resolver.resolve(ask());
			}
		});
		return deferred.promise;
	};
	return ask();
}
function askCustom(rl, name, version, repository){
	function ask(){
		var deferred = when.defer();
		rl.multilineQuestion('Enter url, path or git repository \n> ', function(answer){
			answer = answer.trim();
			if(!answer.length){
				return deferred.resolver.resolve(null);
			} else {
				//TODO check if entered value is valid path, URL, git URL or GitHub user/package spec
				return deferred.resolver.resolve([name, answer])
			}
		});
		return deferred.promise;
	};
	return ask();
}

function getRequireDecision(rl, old_dependencies, metadata){
	if(!metadata){
		return null;
	}
	var answers = ['No', 'yes', 'version'];
	var question = '\nAdd package '+metadata.name;
	if(metadata.version){
		question += ' ['+metadata.version+']';
		answers = answers.concat('=version', '>=version', '~version');
	}
	if(metadata.repository){
		question += ' from '+metadata.repository.type+' repo: '+metadata.repository.url;
		answers = answers.concat('repository');
	}
	answers = answers.concat('custom', 'help');
	question += '\n';
	if(old_dependencies[metadata.name]){
		question += 'Already in dependencies in version: '+old_dependencies[metadata.name]+'\n';
	}
	question += '['+answers.map(function(entry){return entry.substr(0,1);}).join('/')+']: ';
	function _ask(){
		var deferred = when.defer();
		rl.multilineQuestion(question, function handleResponse(response){
			if(!response){
				return deferred.resolver.resolve(null);
			}
			var match = answers.filter(function(entry){
				return entry.toLowerCase().indexOf(response.trim().toLowerCase()) === 0;
			})[0];
			if(!match){
				rl.write('Invalid input. Try again.\n'.red);
				return deferred.resolver.resolve(_ask());
			}
			switch(match.toLowerCase()){
				case 'no':
					return deferred.resolver.resolve(null);
				case 'yes':
					return deferred.resolver.resolve([metadata.name, '*']);
				case '=version':
					return deferred.resolver.resolve([metadata.name, metadata.version]);
				case '>=version':
					return deferred.resolver.resolve([metadata.name, '>='+metadata.version]);
				case '~version':
					return deferred.resolver.resolve([metadata.name, '~'+metadata.version]);
				case 'repository':
					if(metadata.repository.type != 'git'){
						return deferred.resolver.reject('Only git repositories are supported, sorry.');
					}
					var url = metadata.repository.url;
					if(url.substr(0,3) !== 'git'){
						url = 'git+'+url;
					}
					return deferred.resolver.resolve([metadata.name, url]);
				case 'custom':
					askCustom(rl, metadata.name, metadata.version, (metadata.repository || {}).url).then(deferred.resolver.resolve, deferred.resolver.reject);
					return;
				case 'version': 
					askVersion(rl, metadata.name, metadata.version).then(deferred.resolver.resolve, deferred.resolver.reject);
					return;
				case 'help': 
					rl.write('['+answers.join('/')+']\n');
					rl.multilineQuestion(question.split('\n').pop(), handleResponse);
					return;
					
			}
		});
		return deferred.promise;
	}
	return _ask();
}
function grepModules(module_directory){
	var deferred = when.defer();
	var matches = "";
	var error = "";
	var find_args = [module_directory,
		'-iname', '*.js',
		'-!', '-path', module_directory+'*/node_modules/*',
		'-!', '-path', module_directory+'node_modules/*',
		'-!', '-path', '*/.git/*',
		'-exec', 'grep', '-ho', 'require[[:blank:]]*([\'\"\./[:alnum:]_\\-]\\+)', '{}', '+'];
	var grep = ChildProcess.spawn('find', find_args);
	grep.stdout.on('data', function(data){matches += data.toString();});
	grep.stderr.on('data', function(data){error += data.toString();});
	grep.on('close', function(status){
		if(status > 2){
			deferred.resolver.reject(new Error(error));
			return;
		}
		deferred.resolver.resolve(matches);
		return;
	});
	return deferred.promise;
}

function main(rl, module_directory){
	var modules_grep_promise = grepModules(module_directory).then(function(matches){
		matches = matches.substr(0, matches.length-1).split('\n');
		matches = matches.map(function(entry){
			var guess_argument = entry.match(/require\s*\(\s*'(\w[\w\-\.]+?)(?:\/[\/\w\.]+)?'|"(\w[\w\-\.]+?)(?:\/[\/\w\.]+)?"\s*\)/);
			if(!guess_argument){
				return null;
			} else {
				return guess_argument[1] || guess_argument[2];
			}
		})
		return matches;
	});
	var module_metadata_promise = getModuleMetadata(module_directory).otherwise(function(err){
		rl.write('Could not load module metadata. Please be sure to run `npm init` first.\n');
		throw err;
	});
	var dep_metadata_promise = when.all([module_metadata_promise, getModulePaths(module_directory), modules_grep_promise]).then(
		function(resolution){
			var metadata = resolution[0];
			var paths = resolution[1];
			var matches = resolution[2];
			matches = matches.filter(function(value, index, self){
				return !!value //remove nulls
					&& self.indexOf(value) === index //remove duplicates
					&& bundled_modules.indexOf(value) < 0 //remove modules bundled with node
					&& value != metadata.name; //don't depend on yourself. You have friends for that!
			});
			return when.map(matches, function(entry){
				return getDependenciesMetadata(paths, entry).otherwise(function(array){
					rl.write('Could not find metadata about module: '+ entry+'\n');
					return null;
				});
			});
	});
	var require_decision_promise = when.all([dep_metadata_promise, module_metadata_promise]).then(function(results){
		return when.map(results[0], when.guard(when.guard.n(1), getRequireDecision.bind(null, rl, results[1].dependencies || {})));
	});
	
	var calculate_new_deps_promise = when.all([require_decision_promise, module_metadata_promise]).then(function(resolution){
		var new_dep_request = resolution[0];
		var metadata = resolution[1];
		if(!metadata.dependencies){
			metadata.dependencies = {};
		}
		var new_deps = {};
		for(var key in metadata.dependencies){
			new_deps[key] = metadata.dependencies[key];
		}
		
		new_dep_request.forEach(function(entry){
			if(!entry){
				return;
			}
			new_deps[entry[0]] = entry[1];
		});
		return new_deps;
	})
	
	var confirm_and_write_promise = when.all([module_metadata_promise, calculate_new_deps_promise]).then(function(resolution){
		var metadata = resolution[0];
		var new_deps = resolution[1];
		
		rl.write('\nOld dependencies:\n'.bold.green)
		rl.write(util.inspect(metadata.dependencies)+'\n');
		rl.write('\nNew dependencies:\n'.bold.red)
		rl.write(util.inspect(new_deps)+'\n');
		var deferred = when.defer();
		
		function confirm(){
			rl.multilineQuestion('Overwrite dependencies in file '+module_directory+'/package.json'+' ?\n[y/n]: ', function(response){
				if(!response.trim()){
					confirm();
					return;
				}
				if('yes'.indexOf(response.trim().toLowerCase()) === 0){
					var new_metadata = {};
					for(var key in metadata){
						new_metadata[key] = metadata[key];
					}
					new_metadata.dependencies = new_deps;
					rl.write('Overwriting...\n');
					fs.writeFile(module_directory+'/package.json',
						JSON.stringify(new_metadata, undefined, '  '),
						when.nodefn.createCallback(deferred.resolver)
					);
				} else if ('no'.indexOf(response.trim().toLowerCase() === 0)){
					rl.write('Aborted overwrite\n');
					deferred.resolve(false);
				} else {
					confirm();
					return;
				}
			});
		}
		
		confirm();
		return deferred.promise;
	});
	
	return confirm_and_write_promise;
}
rl.multilineQuestion = function(question, callback){
	var ml_question = question.toString().split('\n');
	if(ml_question.length > 1){
		this.write(ml_question.splice(0, ml_question.length-1).join('\n')+'\n');
	}
	this.question(ml_question[0], callback);
}

realpathPromise(optimist.argv._[0] || process.cwd()).then(
	main.bind(null, rl)
).otherwise(function(err){
	process.stderr.write(err.stack+'\n');
}).ensure(
	rl.close.bind(rl)
);
